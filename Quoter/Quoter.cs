using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Exts;

/// <summary>
/// A tool that for a given C# program constructs Roslyn API calls to create a syntax tree that
/// describes this program. As opposed to SyntaxTree.ParseText() that creates the syntax tree object
/// graph in runtime, Quoter returns the C# source code that will construct such syntax tree object
/// graph when compiled and executed.
/// </summary>
/// <example>
/// new Quoter().Quote("class C{}") returns:
/// 
/// Syntax.CompilationUnit()
/// .WithMembers(
///     Syntax.List&lt;MemberDeclarationSyntax&gt;
///         Syntax.ClassDeclaration(
///             Syntax.Identifier(
///                 @"C"))
///         .WithKeyword(
///             Syntax.Token(
///                 SyntaxKind.ClassKeyword,
///                 Syntax.TriviaList(
///                     Syntax.Space)))
///         .WithOpenBraceToken(
///             Syntax.Token(
///                 SyntaxKind.OpenBraceToken))
///         .WithCloseBraceToken(
///             Syntax.Token(
///                 SyntaxKind.CloseBraceToken))))
/// .WithEndOfFileToken(
///     Syntax.Token(
///         SyntaxKind.EndOfFileToken))
/// </example>
public class Quoter
{
    public bool OpenParenthesisOnNewLine { get; set; }
    public bool ClosingParenthesisOnNewLine { get; set; }
    public bool UseDefaultFormatting { get; set; }
    public bool RemoveRedundantModifyingCalls { get; set; }

    public Quoter ( )
    {
        UseDefaultFormatting = true;
        RemoveRedundantModifyingCalls = true;
    }
    public Quoter (bool useDefaultFormatting = true, bool removeRedundantModifyingCalls = true )
    {
        UseDefaultFormatting = useDefaultFormatting;
        RemoveRedundantModifyingCalls = removeRedundantModifyingCalls;
    }
    /// <summary>
    /// Given the input C# program <paramref name="sourceText"/> returns the C# source code of
    /// Roslyn API calls that recreate the syntax tree for the input program.
    /// </summary>
    /// <param name="sourceText">A C# program (one compilation unit)</param>
    /// <returns>A C# expression that describes calls to the Roslyn syntax API necessary to recreate
    /// the syntax tree for the source program.</returns>
    public string Quote ( string sourceText )
    {
        var sourceTree = CSharpSyntaxTree.ParseText(sourceText);
        return Quote( sourceTree.GetRoot( ) );
    }

    /// <summary>
    /// Given the input C# syntax node <paramref name="node"/> returns the C# source code of
    /// Roslyn API calls that recreate the syntax node.
    /// </summary>
    /// <param name="sourceText">A C# syntax node</param>
    /// <returns>A C# expression that describes calls to the Roslyn syntax API necessary to recreate
    /// the input syntax node.</returns>
    public string Quote ( SyntaxNode node )
    {
        ApiCall rootApiCall = Quote(node, name: null);
        if ( UseDefaultFormatting )  rootApiCall.Add( new MethodCall( ".NormalizeWhitespace") );
        string generatedCode = Print(rootApiCall);
        return generatedCode;
    }

    /// <summary>
    /// Calls the Roslyn syntax API to actually create the syntax tree object and return the source
    /// code generated by the syntax tree.
    /// </summary>
    /// <param name="apiCallString">Code that calls Roslyn syntax APIs as a string</param>
    /// <returns>The string that corresponds to the code of the syntax tree.</returns>
    //public string Evaluate(string apiCallString, bool normalizeWhitespace = false)
    //{
    //    var generatedNode = evaluator.Evaluate(apiCallString) as SyntaxNode;
    //    if (normalizeWhitespace)
    //    {
    //        generatedNode = generatedNode.NormalizeWhitespace();
    //    }

    //    var resultText = generatedNode.ToFullString();
    //    return resultText;
    //}

    //private string Evaluate(ApiCall apiCall, bool normalizeWhitespace = false)
    //{
    //    return Evaluate(Print(apiCall), normalizeWhitespace);
    //}

    /// <summary>
    /// Recursive method that "quotes" a SyntaxNode, SyntaxToken, SyntaxTrivia or other objects.
    /// </summary>
    /// <returns>A description of Roslyn API calls necessary to recreate the input object.</returns>
    private ApiCall Quote ( object treeElement, string name = null )
    {
        if ( treeElement is SyntaxTrivia )         return QuoteTrivia( (SyntaxTrivia)treeElement );
        if ( treeElement is SyntaxToken  )         return QuoteToken( (SyntaxToken)treeElement, name );
        if ( treeElement is SyntaxNodeOrToken )
        {
            SyntaxNodeOrToken syntaxNodeOrToken = (SyntaxNodeOrToken)treeElement;
            if ( syntaxNodeOrToken.IsNode )        return QuoteNode( syntaxNodeOrToken.AsNode( ), name );
            return QuoteToken( syntaxNodeOrToken.AsToken( ), name );
        }
        return QuoteNode( (SyntaxNode)treeElement, name );
    }

    /// <summary>
    /// The main recursive method that given a SyntaxNode recursively quotes the entire subtree.
    /// </summary>
    private ApiCall QuoteNode ( SyntaxNode node, string name )
    {
        List<ApiCall> quotedPropertyValues = QuotePropertyValues(node);
        MethodInfo factoryMethod = PickFactoryMethodToCreateNode(node);

        var factoryMethodCall = new MethodCall(factoryMethod.DeclaringType.Name + "." + factoryMethod.Name);

        var codeBlock = new ApiCall(name, factoryMethodCall);

        AddFactoryMethodArguments( factoryMethod, factoryMethodCall, quotedPropertyValues );
        AddModifyingCalls( node, codeBlock, quotedPropertyValues );

        return codeBlock;
    }

    /// <summary>
    /// Inspects the property values of the <paramref name="node"/> object using Reflection and
    /// creates API call descriptions for the property values recursively. Properties that are not
    /// essential to the shape of the syntax tree (such as Span) are ignored.
    /// </summary>
    private List<ApiCall> QuotePropertyValues ( SyntaxNode node )
    {
        var result = new List<ApiCall>();

        var properties = node.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);

        // Filter out non-essential properties listed in nonStructuralProperties
        result.AddRange( properties
            .Where( propertyInfo => !nonStructuralProperties.Contains( propertyInfo.Name ) )
            .Select( propertyInfo => QuotePropertyValue( node, propertyInfo ) )
            .Where( apiCall => apiCall != null ) );

        // HACK: factory methods for the following node types accept back the first "kind" parameter
        // that we filter out above. Add an artificial "property value" that can be later used to
        // satisfy the first parameter of type SyntaxKind.
        if ( node is AccessorDeclarationSyntax ||
            node is BinaryExpressionSyntax ||
            node is ClassOrStructConstraintSyntax ||
            node is CheckedExpressionSyntax ||
            node is CheckedStatementSyntax ||
            node is ConstructorInitializerSyntax ||
            node is GotoStatementSyntax ||
            node is InitializerExpressionSyntax ||
            node is LiteralExpressionSyntax ||
            node is MemberAccessExpressionSyntax ||
            node is OrderingSyntax ||
            node is PostfixUnaryExpressionSyntax ||
            node is PrefixUnaryExpressionSyntax ||
            node is DocumentationCommentTriviaSyntax ||
            node is SwitchLabelSyntax ||
            node is YieldStatementSyntax )
        {
            result.Add( new ApiCall( "Kind", "SyntaxKind." + node.CSharpKind( ).ToString( ) ) );
        }

        return result;
    }

    /// <summary>
    /// Quote the value of the property <paramref name="property"/> of object <paramref
    /// name="node"/>
    /// </summary>
    private ApiCall QuotePropertyValue ( SyntaxNode node, PropertyInfo property )
    {
        var value = property.GetValue(node, null);
        var propertyType = property.PropertyType;

        if ( propertyType == typeof(SyntaxToken) )      return QuoteToken( (SyntaxToken)value, property.Name );
        if ( propertyType == typeof(SyntaxTokenList) )  return QuoteList( (IEnumerable)value, property.Name );
        

        if ( propertyType.IsGenericType &&
            ( propertyType.GetGenericTypeDefinition( ) == typeof(SyntaxList<>) ||
             propertyType.GetGenericTypeDefinition( ) == typeof(SeparatedSyntaxList<>) ) )
        {
            return QuoteList( (IEnumerable)value, property.Name );
        }

        if ( value is SyntaxNode )   return QuoteNode( (SyntaxNode)value, property.Name );
        if ( value is string )       return new ApiCall( property.Name, "\"" + Escape( value.ToString( ) ) + "\"" );
        if ( value is bool )         return new ApiCall( property.Name, value.ToString( ).ToLowerInvariant( ) );
        return null;
    }

    private ApiCall QuoteList ( IEnumerable syntaxList, string name )
    {
        IEnumerable<object> sourceList = syntaxList.Cast<object>();

        string methodName = "SyntaxFactory.List";
        string listType = null;
        var propertyType = syntaxList.GetType();
        if ( propertyType.IsGenericType )
        {
            var methodType = propertyType.GetGenericArguments()[0].Name;
            listType = methodType;

            if ( propertyType.GetGenericTypeDefinition( ) == typeof(SeparatedSyntaxList<>) )
            {
                listType = "SyntaxNodeOrToken";
                methodName = "SyntaxFactory.SeparatedList";
                sourceList = ( (SyntaxNodeOrTokenList)
                    syntaxList.GetType( ).GetMethod( "GetWithSeparators" ).Invoke( syntaxList, null ) )
                    .Cast<object>( )
                    .ToArray( );
            }

            methodName += "<" + methodType + ">";
        }

        if ( propertyType.Name == "SyntaxTokenList"  )  methodName = "SyntaxFactory.TokenList";
        if ( propertyType.Name == "SyntaxTriviaList" )  methodName = "SyntaxFactory.TriviaList";
   

        var elements = ArgList.Create( sourceList.Select(o => Quote(o)).Where(cb => cb != null).ToArray());
        if ( elements.Count == 0 )  return null;
        if ( elements.Count == 1 )
        {
            methodName = methodName.Replace( ".List", ".SingletonList" ).Replace( ".SeparatedList", ".SingletonSeparatedList" );
        }
        else
        {
            elements = ArgList.Create( new ApiCall("methodName", "new " + listType + "[]",  elements, useCurliesInsteadOfParentheses: true ) );
        }

        var codeBlock = new ApiCall(name, methodName, elements);
        return codeBlock;
    }

    private ApiCall QuoteToken ( SyntaxToken value, string name )
    {
        if ( value == default(SyntaxToken) || value.CSharpKind( ) == SyntaxKind.None )  {  return null;  }

        var arguments = ArgList.Create();
        string methodName = "SyntaxFactory.Token";
        string escapedTokenValueText = "@\"" + Escape(value.ToString()) + "\"";
        object leading = GetLeadingTrivia(value);
        object actualValue;
        object trailing = GetTrailingTrivia(value);

        if ( leading != null || trailing != null )
        {
            leading  = leading  ?? GetEmptyTrivia( "LeadingTrivia"  );
            trailing = trailing ?? GetEmptyTrivia( "TrailingTrivia" );
        }

        if ( value.IsKind( SyntaxKind.IdentifierToken ) )
        {
            methodName = "SyntaxFactory.Identifier";
            if ( value.IsMissing )  {  methodName = "SyntaxFactory.MissingToken"; }
            if ( value.IsMissing )  {  actualValue = value.CSharpKind( );    }
            else                    {  actualValue = escapedTokenValueText;  }

            arguments.AddIfNotNull(  leading );
            arguments.Add( actualValue );
            arguments.AddIfNotNull( trailing );
        }
        else if ( value.IsKindAny(SyntaxKind.XmlTextLiteralToken,
                                  SyntaxKind.XmlTextLiteralNewLineToken,
                                  SyntaxKind.XmlEntityLiteralToken) )
        {
            methodName = "SyntaxFactory.XmlTextLiteral";
            if ( value.IsKind(SyntaxKind.XmlTextLiteralNewLineToken) )   {  methodName = "SyntaxFactory.XmlTextNewLine"; }
            else if ( value.IsKind( SyntaxKind.XmlEntityLiteralToken) )  {  methodName = "SyntaxFactory.XmlEntity";      }

            arguments.Add( leading ?? GetEmptyTrivia( "LeadingTrivia" ),
                           escapedTokenValueText,
                           escapedTokenValueText,
                           trailing ?? GetEmptyTrivia( "TrailingTrivia" ) );
        }
        else if ( ( value.Parent is LiteralExpressionSyntax ||
            value.IsKindAny(SyntaxKind.StringLiteralToken,SyntaxKind.NumericLiteralToken )) &&
            value.IsKindNoneOf( SyntaxKind.TrueKeyword , SyntaxKind.FalseKeyword ,
                                SyntaxKind.NullKeyword , SyntaxKind.ArgListKeyword) )
        {
            methodName = "SyntaxFactory.Literal";
            arguments.Add( leading ?? GetEmptyTrivia( "LeadingTrivia" ) );
            arguments.Add( escapedTokenValueText );
            string escapedValue = value.ToString();
            if ( value.IsKind(SyntaxKind.StringLiteralToken ))  escapedValue = escapedTokenValueText;
            arguments.Add( escapedValue , trailing ?? GetEmptyTrivia( "TrailingTrivia" ) );
        }
        else
        {
            if ( value.IsMissing )  {  methodName = "SyntaxFactory.MissingToken"; }

            if ( value.IsKind(SyntaxKind.BadToken ))
            {
                methodName = "SyntaxFactory.BadToken";
                leading = leading ?? GetEmptyTrivia( "LeadingTrivia" );
                trailing = trailing ?? GetEmptyTrivia( "TrailingTrivia" );
            }

            object tokenValue = value.CSharpKind();

            if ( value.IsKind(SyntaxKind.BadToken) )  {  tokenValue = escapedTokenValueText;  }

            arguments.AddIfNotNull( leading );
            arguments.Add( tokenValue );
            arguments.AddIfNotNull( trailing );
        }

        return new ApiCall( name, methodName, arguments );
    }

    //private static void AddIfNotNull ( List<object> arguments, object value )
    //{
    //    if ( value != null )
    //    {
    //        arguments.Add( value );
    //    }
    //}

    private object GetLeadingTrivia ( SyntaxToken value )
    {
        if ( value.HasLeadingTrivia )
        {
            var quotedLeadingTrivia = QuoteList(value.LeadingTrivia, "LeadingTrivia");
            if ( quotedLeadingTrivia != null )  return quotedLeadingTrivia;
        }
        return null;
    }

    private object GetTrailingTrivia ( SyntaxToken value )
    {
        if ( value.HasTrailingTrivia )
        {
            var quotedTrailingTrivia = QuoteList(value.TrailingTrivia, "TrailingTrivia");
            if ( quotedTrailingTrivia != null ) return quotedTrailingTrivia;
        }
        return null;
    }

    private object GetEmptyTrivia ( string parentPropertyName )
    {
        return new ApiCall( parentPropertyName, "SyntaxFactory.TriviaList", arguments: null );
    }

    private ApiCall QuoteTrivia ( SyntaxTrivia syntaxTrivia )
    {
        string factoryMethodName = "SyntaxFactory.Trivia";
        string text = syntaxTrivia.ToString();
        if ( syntaxTrivia.FullSpan.Length == 0 ||
            ( syntaxTrivia.IsKind(SyntaxKind.WhitespaceTrivia) && UseDefaultFormatting ) )   return null;

        FieldInfo field = null;
        if ( triviaFactoryFields.TryGetValue( syntaxTrivia.ToString( ), out field ) &&
            ( (SyntaxTrivia)field.GetValue( null ) ).CSharpKind( ) == syntaxTrivia.CSharpKind( ) )
        {
            if ( UseDefaultFormatting )  return null;
            return new ApiCall( null, "SyntaxFactory." + field.Name );
        }

        if ( !string.IsNullOrEmpty( text )  &&  string.IsNullOrWhiteSpace( text )  &&  syntaxTrivia.IsKind(SyntaxKind.WhitespaceTrivia) )
        {
            if ( UseDefaultFormatting )   return null;        
            factoryMethodName = "SyntaxFactory.Whitespace";
        }

        if ( syntaxTrivia.IsTriviaAny( SyntaxKind.SingleLineCommentTrivia ,
                                       SyntaxKind.MultiLineCommentTrivia) )        { factoryMethodName = "SyntaxFactory.Comment"; }
        if ( syntaxTrivia.IsKind( SyntaxKind.PreprocessingMessageTrivia ))         { factoryMethodName = "SyntaxFactory.PreprocessingMessage"; }
        if ( syntaxTrivia.IsKind( SyntaxKind.DisabledTextTrivia ))                 { factoryMethodName = "SyntaxFactory.DisabledText"; }
        if ( syntaxTrivia.IsKind( SyntaxKind.DocumentationCommentExteriorTrivia )) { factoryMethodName = "SyntaxFactory.DocumentationCommentExterior"; }

        object argument = "@\"" + Escape(syntaxTrivia.ToString()) + "\"";

        if ( syntaxTrivia.HasStructure )  { argument = QuoteNode( syntaxTrivia.GetStructure( ), "Structure" );  }

        return new ApiCall( null, factoryMethodName, ArgList.Create( argument ) );
    }

    private void AddFactoryMethodArguments (
        MethodInfo factory,
        MethodCall factoryMethodCall,
        List<ApiCall> quotedValues )
    {
        foreach ( var factoryMethodParameter in factory.GetParameters( ) )
        {
            var parameterName = factoryMethodParameter.Name;
            var parameterType = factoryMethodParameter.ParameterType;

            ApiCall quotedCodeBlock = FindValue(parameterName, quotedValues);

            // special case to prefer Syntax.IdentifierName("C") to 
            // Syntax.IdentifierName(Syntax.Identifier("C"))
            if ( parameterName == "name" && parameterType == typeof(string) )
            {
                quotedCodeBlock = quotedValues.First( a => a.Name == "Identifier" );
                var methodCall = quotedCodeBlock.FactoryMethodCall as MethodCall;
                if ( methodCall != null && methodCall.Name == "SyntaxFactory.Identifier" )
                {
                    if ( methodCall.Arguments.Count == 1 )  {  factoryMethodCall.Arguments.Add( methodCall.Arguments[0] ); }
                    else                                    {  factoryMethodCall.Arguments.Add( quotedCodeBlock );            }

                    quotedValues.Remove( quotedCodeBlock );
                    continue;
                }
            }

            // special case to prefer Syntax.ClassDeclarationSyntax(string) instead of 
            // Syntax.ClassDeclarationSyntax(SyntaxToken)
            if ( parameterName == "identifier" && parameterType == typeof(string) )
            {
                var methodCall = quotedCodeBlock.FactoryMethodCall as MethodCall;
                if ( methodCall != null &&
                    methodCall.Name == "SyntaxFactory.Identifier" &&
                    methodCall.Arguments.Count == 1 )
                {
                    factoryMethodCall.Arguments.Add( methodCall.Arguments [ 0 ] );
                    quotedValues.Remove( quotedCodeBlock );
                    continue;
                }
            }

            if ( quotedCodeBlock != null )
            {
                factoryMethodCall.Arguments.Add( quotedCodeBlock );
                quotedValues.Remove( quotedCodeBlock );
            }
            else if ( !factoryMethodParameter.IsOptional )
            {
                throw new InvalidOperationException(
                    string.Format(
                        "Couldn't find value for parameter '{0}' of method '{1}'. Go to QuotePropertyValues and add your node type to the exception list.",
                        parameterName,
                        factory ) );
            }
        }
    }

    ///// <summary>
    ///// Helper to quickly create a list from one or several items
    ///// </summary>
    //private static List<object> CreateArgumentList ( params object [ ] args )
    //{
    //    return new List<object>( args );
    //}

    /// <summary>
    /// Escapes strings to be included within "" using C# escaping rules
    /// </summary>
    private string Escape ( string text, bool escapeVerbatim = true )
    {
        StringBuilder sb = new StringBuilder();
        for ( int i = 0; i < text.Length; i++ )
        {
            string toAppend = text[i].ToString();
            if ( text [ i ] == '"' )                           { toAppend = escapeVerbatim ? "\"\"" : toAppend = "\\\"";  }
            else if ( text [ i ] == '\\' && !escapeVerbatim )  { toAppend = "\\\\";  }
            sb.Append( toAppend );
        }
        return sb.ToString( );
    }

    /// <summary>
    /// Finds a value in a list using case-insensitive search
    /// </summary>
    private ApiCall FindValue ( string parameterName, IEnumerable<ApiCall> values )
    {
        return values.FirstOrDefault( v => parameterName.Equals( v.Name, StringComparison.OrdinalIgnoreCase ) );
    }

    /// <summary>
    /// Static methods on Roslyn.Compilers.CSharp.Syntax class that construct SyntaxNodes
    /// </summary>
    /// <example>Syntax.ClassDeclaration()</example>
    private static readonly Dictionary<string, List<MethodInfo>> factoryMethods = GetFactoryMethods();

    /// <summary>
    /// Five public fields on Roslyn.Compilers.CSharp.Syntax that return trivia: CarriageReturn,
    /// LineFeed, CarriageReturnLineFeed, Space and Tab.
    /// </summary>
    private static readonly Dictionary<string, FieldInfo> triviaFactoryFields = GetTriviaFactoryFields();

    /// <summary>
    /// Gets the five fields on Syntax that return ready-made trivia: CarriageReturn,
    /// CarriageReturnLineFeed, LineFeed, Space and Tab.
    /// </summary>
    private static Dictionary<string, FieldInfo> GetTriviaFactoryFields ( )
    {
        var result = typeof(SyntaxFactory)
            .GetFields(BindingFlags.Public | BindingFlags.Static)
            .Where(fieldInfo => fieldInfo.FieldType == typeof(SyntaxTrivia))
            .Where(fieldInfo => !fieldInfo.Name.Contains("Elastic"))
            .ToDictionary(fieldInfo => ((SyntaxTrivia)fieldInfo.GetValue(null)).ToString());

        return result;
    }

    /// <summary>
    /// Returns static methods on Roslyn.Compilers.CSharp.Syntax that return types derived from
    /// SyntaxNode and bucketizes them by overloads.
    /// </summary>
    private static Dictionary<string, List<MethodInfo>> GetFactoryMethods ( )
    {
        var result = new Dictionary<string, List<MethodInfo>>();

        var staticMethods = typeof(SyntaxFactory).GetMethods( BindingFlags.Public | BindingFlags.Static);

        foreach ( var method in staticMethods )
        {
            var returnTypeName = method.ReturnType.Name;

            List<MethodInfo> bucket = null;
            if ( !result.TryGetValue( returnTypeName, out bucket ) )
            {
                bucket = new List<MethodInfo>( );
                result.Add( returnTypeName, bucket );
            }
            bucket.Add( method );
        }
        return result;
    }

    /// <summary>
    /// Uses Reflection to inspect static factory methods on the Roslyn.Compilers.CSharp.Syntax
    /// class and pick an overload that creates a node of the same type as the input <paramref
    /// name="node"/>
    /// </summary>
    private MethodInfo PickFactoryMethodToCreateNode ( SyntaxNode node )
    {
        string name = node.GetType().Name;

        List<MethodInfo> candidates = null;
        if ( !factoryMethods.TryGetValue( name, out candidates ) )  { throw new NotSupportedException( name + " is not supported" ); }

        int minParameterCount = candidates.Min(m => m.GetParameters().Length);

        // HACK: for LiteralExpression pick the overload with two parameters - the overload with one
        // parameter only allows true/false/null literals
        if ( node is LiteralExpressionSyntax )
        {
            var les = ((LiteralExpressionSyntax)node);
            var res = les.IsKindNoneOf( SyntaxKind.TrueLiteralExpression,
                                        SyntaxKind.FalseLiteralExpression,
                                        SyntaxKind.NullLiteralExpression );
            if (res) {  minParameterCount = 2;  }
        }

        MethodInfo factory = null;

        if ( ( node is BaseTypeDeclarationSyntax || node is IdentifierNameSyntax ) )
        {
            Type desiredParameterType = typeof(string);
            factory = candidates.FirstOrDefault( m => m.GetParameters( ) [ 0 ].ParameterType == desiredParameterType );
            if ( factory != null )  { return factory;  }
        }

        factory = candidates.First( m => m.GetParameters( ).Length == minParameterCount );
        return factory;
    }

    /// <summary>
    /// Adds information about subsequent modifying fluent interface style calls on an object (like
    /// foo.With(...).With(...))
    /// </summary>
    private void AddModifyingCalls ( object treeElement, ApiCall apiCall, List<ApiCall> values )
    {
        var methods = treeElement.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance);

        foreach ( var value in values )
        {
            var properCase = ProperCase(value.Name);
            var methodName = "With" + properCase;
            if ( !methods.Any( m => m.Name == methodName ) ) throw new NotSupportedException( );
            methodName = "." + methodName;

            var methodCall = new MethodCall( methodName, ArgList.Create(value));

            AddModifyingCall( apiCall, methodCall );
        }
    }

    private void AddModifyingCall ( ApiCall apiCall, MethodCall methodCall )
    {
        // TODO: this needs scripting
        ////if (RemoveRedundantModifyingCalls)
        ////{
        ////    var before = Evaluate(apiCall, UseDefaultFormatting);
        ////    apiCall.Add(methodCall);
        ////    var after = Evaluate(apiCall, UseDefaultFormatting);
        ////    if (before == after)
        ////    {
        ////        apiCall.Remove(methodCall);
        ////    }
        ////}

        apiCall.Add( methodCall );
        return;
    }

    /// <summary>
    /// Flattens a tree of ApiCalls into a single string.
    /// </summary>
    private string Print ( ApiCall root )
    {
        var sb = new StringBuilder();
        Print( root, sb, 0, OpenParenthesisOnNewLine, ClosingParenthesisOnNewLine );
        var generatedCode = sb.ToString();
        return generatedCode;
    }

    private static string PrintWithDefaultFormatting ( ApiCall root )
    {
        var sb = new StringBuilder();
        Print( root, sb, 0, openParenthesisOnNewLine: false, closingParenthesisOnNewLine: false );
        var generatedCode = sb.ToString();
        return generatedCode;
    }

    private static void Print (
        ApiCall codeBlock,
        StringBuilder sb,
        int depth = 0,
        bool openParenthesisOnNewLine = false,
        bool closingParenthesisOnNewLine = false )
    {
        Print( codeBlock.FactoryMethodCall, sb, depth,
            useCurliesInsteadOfParentheses: codeBlock.UseCurliesInsteadOfParentheses,
            openParenthesisOnNewLine: openParenthesisOnNewLine,
            closingParenthesisOnNewLine: closingParenthesisOnNewLine );
        if ( codeBlock.InstanceMethodCalls != null )
        {
            foreach ( var call in codeBlock.InstanceMethodCalls )
            {
                PrintNewLine( sb );
                Print( call, sb, depth,
                    useCurliesInsteadOfParentheses: codeBlock.UseCurliesInsteadOfParentheses,
                    openParenthesisOnNewLine: openParenthesisOnNewLine,
                    closingParenthesisOnNewLine: closingParenthesisOnNewLine );
            }
        }
    }

    private static void Print (
        MemberCall call,
        StringBuilder sb,
        int depth,
        bool openParenthesisOnNewLine = false,
        bool closingParenthesisOnNewLine = false,
        bool useCurliesInsteadOfParentheses = false )
    {
        var openParen = useCurliesInsteadOfParentheses ? "{" : "(";
        var closeParen = useCurliesInsteadOfParentheses ? "}" : ")";
        Print( call.Name, sb, depth );

        MethodCall methodCall = call as MethodCall;
        if ( methodCall != null )
        {
            if ( methodCall.Arguments == null ||
                !methodCall.Arguments.Any( ) )   {  Print( openParen + closeParen, sb, 0 );  return;  }

            if ( openParenthesisOnNewLine )      {  PrintNewLine( sb );  Print( openParen, sb, depth );  }
            else                                 {  Print( openParen, sb, 0 );                           }

            PrintNewLine( sb );

            bool needComma = false;
            foreach ( var block in methodCall.Arguments )
            {
                if ( needComma )                 {  Print( ",", sb, 0 );  PrintNewLine( sb );  }
                if ( block is string )           {  Print( (string)block, sb, depth + 1 );     }
                else if ( block is SyntaxKind )  {  Print( "SyntaxKind." + ( (SyntaxKind)block ).ToString( ), sb, depth + 1 );  }
                else if ( block is ApiCall )
                {
                    Print(
                        block as ApiCall,
                        sb,
                        depth + 1,
                        openParenthesisOnNewLine: openParenthesisOnNewLine,
                        closingParenthesisOnNewLine: closingParenthesisOnNewLine );
                }

                needComma = true;
            }

            if ( closingParenthesisOnNewLine )   {  PrintNewLine( sb ); Print( closeParen, sb, depth ); }
            else                                 {  Print( closeParen, sb, 0 );                         }
        }
    }

    private static void PrintNewLine ( StringBuilder sb )
    {
        sb.AppendLine( );
    }

    private static void Print ( string line, StringBuilder sb, int indent )
    {
        PrintIndent( sb, indent );
        sb.Append( line );
    }

    private static void PrintIndent ( StringBuilder sb, int indent )
    {
        sb.Append( new string( ' ', indent * 4 ) );
    }

    private static string ProperCase ( string str )
    {
        return char.ToUpperInvariant( str [ 0 ] ) + str.Substring( 1 );
    }

    /// <summary>
    /// Enumerates names of properties on SyntaxNode, SyntaxToken and SyntaxTrivia classes that do
    /// not impact the shape of the syntax tree and are not essential to reconstructing the tree.
    /// </summary>
    private static readonly string[] nonStructuralProperties =
    {
        "AllowsAnyExpression",               "Arity",  "ContainsAnnotations", "ContainsDiagnostics",
         "ContainsDirectives", "ContainsSkippedText",   "DirectiveNameToken",            "FullSpan",
           "HasLeadingTrivia",   "HasTrailingTrivia",  "HasStructuredTrivia",        "HasStructure",
                    "IsConst",         "IsDirective",            "IsElastic",             "IsFixed",
                  "IsMissing",  "IsStructuredTrivia", "IsUnboundGenericName",               "IsVar",
                       "Kind",            "Language",               "Parent",        "ParentTrivia",
                  "PlainName",                "Span",           "SyntaxTree", 
    };

    /// <summary>
    /// "Stringly typed" representation of a C# property or method invocation expression, with a
    /// string for the property or method name and a list of similarly loosely typed argument
    /// expressions. Simply speaking, this is a tree of strings.
    /// </summary>
    /// <example>
    /// Data structure to represent code (API calls) of simple hierarchical shape such as:
    /// A.B(C, D.E(F(G, H), I))
    /// </example>
    private class ApiCall
    {
        public string Name { get; private set; }
        public MemberCall FactoryMethodCall { get; private set; }
        public List<MethodCall> InstanceMethodCalls { get; private set; }
        public bool UseCurliesInsteadOfParentheses { get; private set; }

        public ApiCall ( ) { }
        public ApiCall ( string parentPropertyName ) { Name = parentPropertyName; }

        public ApiCall ( string parentPropertyName, string factoryMethodName ) : this(parentPropertyName)
        {
            FactoryMethodCall = new MemberCall(factoryMethodName);
        }

        public ApiCall ( string parentPropertyName, string factoryMethodName, ArgList arguments, bool useCurliesInsteadOfParentheses = false ) :
            this(parentPropertyName, new MethodCall( factoryMethodName, arguments ))
        {
            UseCurliesInsteadOfParentheses = useCurliesInsteadOfParentheses;
        }

        public ApiCall ( string name, MethodCall factoryMethodCall ) : this(name)
        {
            FactoryMethodCall = factoryMethodCall;
        }

        public void Add ( MethodCall methodCall )
        {
            if ( InstanceMethodCalls == null ) { InstanceMethodCalls = new List<MethodCall>( );}
            InstanceMethodCalls.Add( methodCall );
        }

        public void Remove ( MethodCall methodCall )
        {
            if ( InstanceMethodCalls == null ) return;
            InstanceMethodCalls.Remove( methodCall );
        }

        public override string ToString ( )
        {
            return Quoter.PrintWithDefaultFormatting( this );
        }
    }

    /// <summary>
    /// Simple data structure to represent a member call, primarily just the string Name.
    /// </summary>
    private class MemberCall
    {
        public MemberCall ( string factoryMethodName )
        {
            this.Name = factoryMethodName;
        }

        public string Name { get; private set; }

        public override string ToString ( )
        {
            var sb = new StringBuilder();
            Quoter.Print( this, sb, 0 );
            return sb.ToString( );
        }
    }

    /// <summary>
    /// Represents a method call that has a Name and an arbitrary list of Arguments.
    /// </summary>
    private class MethodCall : MemberCall
    {

        public MethodCall ( string methodName ) : base( methodName ) { }
        public MethodCall ( string methodName, ArgList argList ) : this(methodName)
        {
            this.Arguments  = argList;
        }

        public ArgList Arguments { get; private set; } = ArgList.Create();

        //public void AddArgument ( object value )
        //{
        //    if ( Arguments == null ) {  Arguments = ArgList.Create( ); }
        //    Arguments.Add( value );
        //}
    }
}

public static class Exts
{
    public static bool IsKind       ( this SyntaxNode   CSNode, SyntaxKind CSKind ) { return CSNode.CSharpKind( ) == CSKind; }
    public static bool IsKindAny    ( this SyntaxNode   CSNode, params SyntaxKind [ ] CSKinds ) { return CSKinds.Any( csk => CSNode.CSharpKind() == csk ); }
    public static bool IsKindNoneOf ( this SyntaxNode   CSNode, params SyntaxKind [ ] CSKinds ) { return CSKinds.All( csk => CSNode.CSharpKind() != csk ); }
    public static bool IsTriviaAny  ( this SyntaxTrivia CSNode, params SyntaxKind [ ] CSKinds ) { return CSKinds.Any( csk => CSNode.IsKind( csk) ); }
    public static bool IsKindAny    ( this SyntaxToken  CSNode, params SyntaxKind [ ] CSKinds ) { return CSKinds.Any( csk => CSNode.CSharpKind() == csk ); }
    public static bool IsKindNoneOf ( this SyntaxToken  CSNode, params SyntaxKind [ ] CSKinds ) { return CSKinds.All( csk => CSNode.CSharpKind() != csk ); }

}

public class ArgList : IEnumerable<object>
{
    private List<object> Args  = new List<object>( );
    public object this [ int index ]  {  get { return Args [ index ];}   }

    private ArgList ( params object [ ] Arguments ) { Args = new List<object>( Arguments ); }

//    public void Add(object Argument ) { Args.Add( Argument ); }
    public void Add(params object[] Arguments) { this.Args.AddRange( Arguments ); }
    public int Count { get { return this.Args.Count; } }

    public static ArgList Create(params object[] Arguments ) {  return new ArgList( Arguments ); }

    IEnumerator<object> IEnumerable<object>.GetEnumerator ( ) { return this.Args.GetEnumerator(); }
    IEnumerator IEnumerable.GetEnumerator ( ) { return this.Args.GetEnumerator(); }

    public void AddIfNotNull ( object value ) { if ( value != null ) { Args.Add( value ); }  }
}